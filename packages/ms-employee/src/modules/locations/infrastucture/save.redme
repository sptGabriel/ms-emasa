import { LocationModel } from '@modules/locations/infrastucture/location.model';
import { Location } from '@modules/locations/domain/location.entity';
import { Model } from 'objection';
import Knex from 'knex';

export interface IRead<T> {
  find(item: T): Promise<T>;
  findOne(id: string): Promise<T>;
  findAll(): Promise<T[]>;
}
export interface IWrite<T> {
  create(item: T): Promise<T>;
  update(id: string, item: T): Promise<T>;
  delete(id: string): Promise<T>;
}
const _validateIsModel = (model: Model): Boolean => {
  let parentClass = Object.getPrototypeOf(model);
  while (parentClass.name !== 'Model' && parentClass.name !== '') {
    parentClass = Object.getPrototypeOf(parentClass);
  }
  if (parentClass.name === 'Model') return true;
  return false;
};
export abstract class BaseRepository<T> implements IWrite<T>, IRead<T> {
  private knex: Knex;
  private model: any;
  constructor(knex: Knex, model: any) {
    this.knex = knex;
    this.model = model;
  }
  public get Model() {
    if (!this.model) throw new Error('Model not implemented.');
    return this.model;
  }
  public get Knex() {
    if (!this.knex)
      throw new Error('Knex connection instance not implemented.');
    return this.knex;
  }
  find(item: T): Promise<T> {
    throw new Error('Method not implemented.');
  }
  public findAll = async (): Promise<T[]> => {
    return await this.model.query();
  };

  public findOne = async (id: string): Promise<T> => {
    return await this.model.query().findById(id);
  };
  public create = async (item: T): Promise<T> => {
    return await this.model.query().insert(item);
  };
  public update = async (id: string, item: T): Promise<T> => {
    const result = await this.model.query().patchAndFetchById(id, item);
    return result;
  };
  public delete = async (id: string): Promise<T> => {
    return await this.model.query().deleteById(id);
  };
}
